## 第4章 复合类型

1.new分配的内存块通常与常规变量声明分配的内存块不同。		
- 变量/指针都存储在称为栈(stack)的内存区域中，而new申请的内存/数据对象是在称为堆(heap)或自由存储区(free store)的内存区域分配的内存。
  
2.使用new和delete时需遵守以下规则		
- 不要使用delete来释放不是new分配的内存；	
- 不要使用delete释放同一个内存块两次；	
- 如果使用new[]为数组分配内存，应使用delete[]来释放；	
- 如果使用new为一个实体分配内存，应使用delete来释放；	
- 对空指针应用delete是安全的。	

![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/de1ab0bf-7dc8-41f0-905d-0f90c126ec59)

![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/ca4f39b8-3faf-4c02-95d8-6ffa7162752a)

3.C++有3种管理内存的方法：自动存储、静态存储和动态存储（有时也叫做自由存储空间或堆）。C++11新增了第四种类型 线程存储。

- 在函数内部定义的常规变量使用自动存储空间，被称为自动变量。自动变量通常存储在栈中，在执行代码块时，其中的变量依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出(LIFO)。
- 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。			
- 动态存储：new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。			
- 数据的生命周期不完全受程序或函数的生存时间控制。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。		
				
4.模板类vector：模板类vector类似于string类，也是一种动态数组，可在运行阶段设置vector对象的长度，可在末尾附加新数据，也可在中间插入新数据。				
- 基本上它是使用new创建动态数组的替代品，实际上vector类确实是使用new和delete来管理内存，但这种工作是自动完成的。			
- 模板类array(C++11):对于需要使用长度固定的数组，C++11新增了模板类array，它也位于名称空间std中，与数组一样，array对象的长度是固定的，使用栈（静态内存分配）而不是自由存储区。				
				
5.C++ 不检查数组的越界，vector和array对象都是如此，但是可以在array和vector对象使用成员函数at()，它可以在运行期间捕获非法索引，程序默认将中断。可以使用成员函数begin()和end()来确定边界。				
				
6.C++98 新增的标准模板库（STL）提供了模板类 vector，它是动态数组的替代品。C+11提供了模板，类array，它是定长数组的替代品。				

## =============================================
### 1.sizeof用于数组名，得到的是整个数组的字节数，如果用于数组元素，得到的是元素的长度，单位是字节数。
### 2.只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组，可以使用下标分别给数组中的元素赋值。
     如果只对数组的一部分进行初始化，则编译器将把其它元素设为0.如果初始化数组时方括号内([])为空，C++编译器将计算元素个数。
### 3.C++11数组初始化方法
     数组以前就可使用列表初始化，但C++11中的列表初始化新增了一些功能。
     1）初始化数组时，可省略等号(=):
       double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};
     2）可以不在大括号内包含任何东西，这将把所有元素都设置为零：
       unsigned int counts[10] = {};
       float balances[100] {};
     3）列表初始化禁止缩窄转换：
       long plifs[] = {25, 92, 3.0};   		// 浮点转换为整型是缩窄操作
       char slifs[4] {'h', 'i', 1122011, '\0'};		// 假设char是8位，1122011超出了char变量的取值范围
       char tlifs[4] {'h', 'i', 112, '\0'};		// 可以通过编译，112虽是int，但可以存储在char内

### 4.字符串
    C-风格字符串，以空字符'\0'结尾，ASCII码位0，用以标记字符串的结尾。（字符数组没有\0结尾，不是字符串）
    对于字符数组的初始化，可使用""括起来的字符串，这种字符串被称为字符串常量或字符串字面值，引号括起来的字符串隐式地包含结尾的空字符，所以不用显式的包括它。
    字符串很长，无法放到同一行中：任何两个由空白（空格、制表符、换行符）分隔的字符串常量都将自动拼接成一个。
    
### 5.字符串输入
    char name[10];
    cin >> name;
    //cin使用空白（空格、制表符、换行符）来确定字符串结束位置，这意味着cin在获取字符数组输入时只读取一个单词，另外这种方式对于输入的字符超出数组长度的情况无法处理
    //此处需要面向行而不是面向单词的方法
    istream中的类（如cin）提供了一些面向行的类成员函数：getline()和get()。这两个函数都读取一行输入，直到到达换行符。getline()将丢弃换行符，而get()将换行符保留在输入序列中。

### 6.结构体变量创建
    struct inflatable goose; 	// keyword struct required in C
    inflatable vincent;		// keyword struct not required in C++

### 7.C++结构体除了有成员变量之外，还可以有成员函数，但这些高级特性通常被用于类中，而不是结构中。

### 8.结构中的位字段
    与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建于某个硬件设备上的寄存器对应的数据结构非常方便。
    字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数，可以使用没有名称的字段来提供间距，每个成员都被称为位字段
      struct toggle_register
      {
        unsigned int SN : 4;
	    unsigned int : 4;
 	    bool goodIn : 1;
  	    bool goodTrogle : 1;
      };
     初始化
     toggle_register tr = {14, true, false}; //未给无名称的字段赋值
     位字段通常用于低级编程中，也可使用整型和按位运算符代替。
### 9.下面的声明创建了一个指针(p1)和一个int变量(p2)
    int * p1, p2;
    对于每个指针变量名，都需要使用一个*.
### 10.指针，在运行阶段分配未命名的内存以存储值。在C语言中，可以用库函数malloc()来分配内存；在C++中人可以这样做，但C++中有更好的方法-new运算符。
### 11.使用delete的关键在于，将它用于new分配的内存，这并不意味着使用用于new的指针，而是用于new的地址
    int * ps = new int;		// allocate memory
    int * pq = ps;		//set second pointer to same block
    delete pq;			// delete with second pointer
    一般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。但对于返回指针的函数，使用另一个指针确实有道理。
### 12.不能使用sizeof运算符来确定动态分配的数组包含的字节数。
### 13.将指针变量加1后，其增加的值等于指向的类型占用的字节数。
### 14.数组名是数组第一个元素的地址（类型：指向元素的指针），对数组名使用地址运算符(&)得到的是整个数组的地址（类型：指向整个数组的指针），这种区别在指针运算时会有差异。
### 15.数组表示法和指针表示法：使用方括号数组表示法等同于对指针解除引用
### 16.在cout和多数C++表达式中，char数组名、char指针以及用引号括起来的字符串常量都被解释为字符串第一个字符的地址。
### 17.在将字符串读入程序时，应使用已分配的内存地址。改地址可以是数组名，也可以是使用new初始化过的指针，string对象。

