## 1.静态类成员：类的所有对象共享一个静态成员
    静态数据成员在类声明中声明，在包含类方法的文件中初始化。
    //类声明 static int num_strings;
    //类方法：int StringBad::num_strings = 0;
    初始化使用作用域运算符来指出静态成员所有的类。
    但如果静态成员是整型或枚举型const，则可以在类声明中初始化。

    不能在类声明中初始化静态成员变量，声明描述了如何分配内存，但并不分配内存
## 2.当程序结束时，删除对象可释放对象本身占用的内存（指针），但不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句确保对象过期时，有构造函数使用new分配的内存被释放。
## 3.当用一个对象来初始化另一个对象时，编译器将自动生成复制构造函数，它创建源对象的一个副本。此种方式生成的对象在消失时会调用析构函数。（将对象传递给函数作为参数，生成临时变量的情况）
    具体地说，C++自动提供了下面这些成员函数：
    默认构造函数，如果没有定义构造函数
    默认析构函数，如果没有定义
    复制构造函数，如果没有定义
    赋值运算符，如果没有定义
    地址运算符，如果没有定义
    隐式地址运算符返回调用对象的地址（即this指针地值）。这与我们地初衷一致。
### 默认构造函数
    如果没有提供任何构造函数，C++将创建默认构造函数（不接受任何参数，也不执行任何操作的构造函数）
    这种默认构造函数创建对象类似于一个常规的自动变量，它的值在初始化时是未知的。
    如果定义了构造函数，C++将不会定义默认构造函数。
### 复制构造函数
    复制构造函数用于将一个对象复制到新创建的对象中。用于初始化过程中，包括按值传递参数，而不是常规的赋值过程中。
    类的复制构造函数原型通常如下：
    Class_name(const Class_name &);
    它接受一个指向类对象的常量引用作为参数
#### 何时调用复制构造函数
    新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。
    StringBad ditto(motto);
    StringBad metto = motto;
    StringBad also = StringBad(motto);
    StringBad * pStringBad = new StringBad(motto);
    中间的两种声明可能会使用复制构造函数直接创建metto和also,也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metto和also，这取决于具体的实现。
    最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给pStringBad指针。
    每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。
    按值传递意味着创建原始变量的一个副本，编译器生成临时对象时，也将使用复制构造函数。
#### 默认的复制构造函数的功能
    默认的复制构造函数逐个复制非静态成员（成员赋值也称为浅复制），复制的是成员的值。如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。
#### 提供显式复制构造函数（类中包含指针指向堆内存，使用静态数据成员记录）
    显式复制构造函数，深度复制（一些类成员使用new初始化的、指向数据的指针，而不是数据本身）
## 4.赋值运算符
    ANSI C允许结构体赋值，C++允许类对象赋值，这是通过为类重载赋值运算符实现的。
    原型如下：
    Class_name & Class_name::operator=(const Class_name &);
    它接受并返回一个指向类对象的引用
### 何时调用赋值运算符
    将已有的对象赋给(=)另一个对象时，将使用重载的赋值运算符(取决于实现，直接创建对象还是生成临时对象，调用赋值运算符对成员进行逐个复制)
    与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则将使用为这个类定义的赋值运算符来复制该成员，静态数据成员不受影响。
## 5.静态类成员函数
    可以将成员函数声明为静态的（函数声明必须包含关键字static，在函数定义中不能包含关键字static）
    不能通过对象调用静态成员函数（静态成员函数不能使用this指针）。如果静态成员函数是在公有部分声明的，可以使用类名和作用域解析运算符来调用它。
    由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。
## 6.使用new初始化对象


### 定位new与显式调用析构函数
    对于使用常规new运算符申请空间，再在此使用定位new运算符申请对象的情况，需要先显式调用析构函数释放对象内存，再使用delete释放原本的空间。
  ![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/ca43bbc8-5bc1-4aa7-9297-7d7f25f1b031)
  
## 7.嵌套结构和类
### 在类声明中声明的结构、类或枚举被称为是被嵌套在类中，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。
如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型；

如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被类声明的类型。
## 8.成员初始化列表与C++11的类内初始化
### 成员初始化列表的初始化工作是在对象创建时完成的，此时还未执行括号中的任何代码
成员初始化列表由逗号分隔的初始化列表组成（前面带冒号）。它位于参数列表的右括号之后、函数体左括号之前。
请注意以下几点：
- 这种格式只能用于构造函数；
- 必须使用这种格式来初始化非静态const数据成员
- 必须使用这种格式来初始化引用数据成员
- 数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。
