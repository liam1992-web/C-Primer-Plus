## 1.静态类成员：类的所有对象共享一个静态成员
    静态数据成员在类声明中声明，在包含类方法的文件中初始化。
    //类声明 static int num_strings;
    //类方法：int StringBad::num_strings = 0;
    初始化使用作用域运算符来指出静态成员所有的类。
    但如果静态成员是整型或枚举型const，则可以在类声明中初始化。

    不能在类声明中初始化静态成员变量，声明描述了如何分配内存，但并不分配内存
## 2.当程序结束时，删除对象可释放对象本身占用的内存（指针），但不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句确保对象过期时，有构造函数使用new分配的内存被释放。
## 3.当用一个对象来初始化另一个对象时，编译器将自动生成复制构造函数，它创建源对象的一个副本。此种方式生成的对象在消失时会调用析构函数。（将对象传递给函数作为参数，生成临时变量的情况）
    具体地说，C++自动提供了下面这些成员函数：
    默认构造函数，如果没有定义构造函数
    默认析构函数，如果没有定义
    复制构造函数，如果没有定义
    赋值运算符，如果没有定义
    地址运算符，如果没有定义
    隐式地址运算符返回调用对象的地址（即this指针地值）。这与我们地初衷一致。
### 默认构造函数
    如果没有提供任何构造函数，C++将创建默认构造函数（不接受任何参数，也不执行任何操作的构造函数）
    这种默认构造函数创建对象类似于一个常规的自动变量，它的值在初始化时是未知的。
    如果定义了构造函数，C++将不会定义默认构造函数。
### 复制构造函数
    复制构造函数用于将一个对象复制到新创建的对象中。用于初始化过程中，包括按值传递参数，而不是常规的赋值过程中。
    类的复制构造函数原型通常如下：
    Class_name(const Class_name &);
    它接受一个指向类对象的常量引用作为参数
#### 何时调用复制构造函数
    新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。
    StringBad ditto(motto);
    StringBad metto = motto;
    StringBad also = StringBad(motto);
    StringBad * pStringBad = new StringBad(motto);
    中间的两种声明可能会使用复制构造函数直接创建metto和also,也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metto和also，这取决于具体的实现。
    最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给pStringBad指针。
    每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。
    按值传递意味着创建原始变量的一个副本，编译器生成临时对象时，也将使用复制构造函数。
#### 默认的复制构造函数的功能
    默认的复制构造函数逐个复制非静态成员（成员赋值也称为浅复制），复制的是成员的值。如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。
#### 提供显式复制构造函数（类中包含指针指向堆内存，使用静态数据成员记录）
    显式复制构造函数，深度复制（一些类成员使用new初始化的、指向数据的指针，而不是数据本身）
## 4.赋值运算符
    ANSI C允许结构体赋值，C++允许类对象赋值，这是通过为类重载赋值运算符实现的。
    原型如下：
    Class_name & Class_name::operator=(const Class_name &);
    它接受并返回一个指向类对象的引用
### 何时调用赋值运算符
    将已有的对象赋给(=)另一个对象时，将使用重载的赋值运算符(取决于实现，直接创建对象还是生成临时对象，调用赋值运算符对成员进行逐个复制)
    与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则将使用为这个类定义的赋值运算符来复制该成员，静态数据成员不受影响。
    