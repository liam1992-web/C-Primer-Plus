## 第8章 函数探幽
1.内联函数：使用相应函数的代码替换函数调用，无函数跳转	

    目的：提高程序运行速度的一项改进		
	区别：组合到程序中的方式，函数调用/函数副本		
	效果：运行速度比常规函数稍快，但是需要占用更多的内存。（在程序调用到这一函数的地方会包含此函数的代码副本）		
	使用范围：当函数经常需要被调用		
	注意点：内联函数和常规函数一样，参数是值传递；与C语言的宏定义不同，宏是文本替换。		

2.引用变量	

    引用是已定义的变量的别名，可以交替使用引用和原变量名来表示该变量			
	引用变量主要是用来作函数的形参，通过将引用变量用作参数，函数将使用原始数据而不是副本，这为函数处理大型结构提供了一种方便的途径			
	C++使用&来声明引用，作为类型标识符			
	声明引用时需进行初始化，不能先声明再赋值			
	引用更接近const指针，必须在创建时初始化，一旦和某个变量关联起来就将一直效忠于它。			
		int & rodents = rats;		
		实际等于		
		int * const pr = &rats;		
		//rodents与*pr相同		
				
	引用变量作为函数参数时，对函数参数的要求会更多，因为它是引用，需要传递的是一个变量，而不应该是一个表达式；但对于按值传递的函数参数则没有这些要求。			

3.临时变量、引用参数和const	

    函数参数为const引用时			如果实参与引用参数不匹配					C++将生成临时变量	
			                     	1）实参的类型正确，但不是左值						
			                     	2）实参的类型不正确，但可以转换为正确的类型						

![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/701eaa2d-851c-40a0-af9d-20f0319de7fe)

在这些情况下，编译器都将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器便可以随意删除。

![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/0b5fdfec-4604-4f73-8a10-a1acaf48fe65)

右值引用

![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/bc2cd0a0-36fe-45ce-9468-23dcb2747562)

4.返回引用时需要注意的问题	
- 函数返回的是引用时，返回的不应该是函数内部定义的临时变量
- 对于函数内用new分配新的存储空间，并返回指向该内存空间的指针，是可行的
![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/437f6201-ed6d-49fa-a40f-f97d51934550)

5.将引用用于类对象

![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/77f6edad-321e-4b93-b078-6c7d12cf2511)
![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/67913d13-91ab-47f7-807d-c5c0ebf61f0a)


6.对象、继承和引用		

	ostrecam 和 ofstrcam 类凸显了引用的一个有趣属性。	
	ofstrcam 对象可以使用 ostream类的方法，这使得文件输入/输出的格式与控制台输入/输出相同。	
	使得能够将特性从一个类传递给另一个类的语言特性被称为继承，这将在第13章详细讨论。	
	简单地说，ostream是基类（因为 ofstream是建立在它的基础之上的)，而 ofstream是派生类（因为它是从 ostream 派生而来的)。	
	派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法 precision()和 setf()	
		
	继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。	
	这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。	
	例如，参数类型为ostream&的函数可以接受ostream 对象（如 cout）或您声明的ofstream对象作为参数。	

7.默认参数		

	当函数调用中省略了实参时自动使用的一个值	
	通过函数原型告知编译器，赋值	
	对于带参数列表的函数，必须从右向左添加默认值	

8.函数重载	
			
	函数多态/函数重载 可使用多个同名的函数，完成相同的工作，但使用不同的参数列表			
	函数的参数列表，也称为函数特征标，参数数目和/或参数类型不同，则特征标不同			
	编译器在检查函数特征标时，把类型引用和类型本身视为同一个特征标			
		double cube(double x);		
		double cube(double & x);		
		cout << cube(x);		
		参数x与double x原型和double & x原型都匹配！！		
	仅当函数基本上执行相同的任务，但使用不同形式的任务时才应采用函数重载			

9.函数模板	

	函数模板是通用的函数描述，使用泛型来定义函数，其中的泛型可用具体的类型（如int或double）替换
	通过将类型作为参数传递给模板，可使编译器生成该类型的函数
	模板并不创建任何函数，而是告诉编译器如何定义函数
	函数模板不能缩短可执行程序，最终生成的是各自独立的函数定义，最终的代码不包含任何模板，而只包含了为程序生成的实际函数
	使用模板的好处是，它使生成多个函数定义更简单、更可靠。
	
*重载的模板*	
	
为特定类型提供具体化的模板定义	
具体化函数定义，称为显式具体化，其中包含所需的代码，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板	
第三代具体化(ISO/ANSI C++标准)	
	对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本
	显式具体化的原型和定义应以template<>打头，并通过名称来指出类型
	具体化优先于常规模板，而非模板函数优先于具体化和常规模板

10.实例化和具体化

	函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案		
	编译器使用模板为特定类型生成函数定义时，得到的是模板实例		
	使用具体类型的模板实例就是函数定义，这种实例化方式被称为隐式实例化		
	显式实例化，可直接命令编译器创建特定的实例，如Swap<int>()，声明所需的种类用<>符号指示类型，并在声明前加上关键字template.		
		template void Swap<int>(int, int);	
	显式具体化使用templat<>打头,它有自己的函数定义而不使用模板生成函数定义		
		template<> void Swap<int>(int &, int &);	
		template<> void Swap(int &, int &);	
			
	//隐式基于模板，在函数调用后生成函数定义；显式实例化，根据命令生成函数定义；显式具体化使用自己的函数定义，而不是基于模板		
	隐式实例化、显式实例化和显式具体化统称为具体化，它们的相同之处在于它们表示的都是使用具体类型的函数定义，而不是通用描述		

11.重载解析	

	对于函数重载、函数模板和函数模板重载，需要决定函数调用使用哪一个函数定义，需要进行重载解析

## =======================================================================
### 1.应在定义引用变量时对其进行初始化。函数调用使用实参初始化形参，因此函数的引用参数被初始化为函数调用传递的实参。
### 2.临时变量、引用参数和const
### 3.引用、临时变量、函数返回、new
### 4.1 默认参数：使用不同数目的参数调用同一个函数
### 4.2 函数重载：可使用多个同名的函数
    编译器在检查函数特征标时，把类型引用和类型本身视为同一个特征标
    函数重载的前提是特征标（函数参数）不同，而不是函数返回类型。
	如果函数参数有const和非const的差异，则会根据实参的类型进行重载
	如果形参是const，则可接受实参的const和非const形式
	如果形参是非const形式，则实参只能是非const形式
### 4.2.1 重载引用参数（左值引用、右值引用、const左值引用）
    不同引用类型的重载，对于多种特征标的函数，编译器将调用最匹配的版本  
    const左值引用可以接收 可修改的左值参数、const左值参数和右值参数（如两个double值的和）
![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/eb93b079-a258-4d6c-a142-0f838bffbf22)
	
### 4.3 函数模板
    要让编译器知道程序需要一个特定形式的函数（定义）时，只需在程序中使用此函数即可。
	编译器将检查函数所使用的参数类型，并根据模板生成相应的函数。
### 4.4 模板的局限性
    编写的模板函数对于一些类型（指针、结构、数组）在编程中使用运算符是无法完成的，与一般类型操作不同，一种是可以对运算符进行重载，另一种是可为特定类型提供具体化的模板定义。
### 4.5 第三代具体化(ISO/ANSI C++标准)	
对于*给定的函数名*，可以有*非模板函数*、*模板函数*和*显式具体化模板函数*以及它们的*重载版本*

*非模板函数* 优先于 具体化和常规模板，*具体化* 优先于*常规模板*

显式具体化的原型和定义应以template<>打头，并通过名称来指出类型

几种用于交换job结构的非模板函数、模板函数和具体化原型：

    // not template function prototype
    void Swap(job&, job &);

	// template prototype
	template<typename T>
	void Swap(T &, T &);

	// explicit specialization for the job type
	template<> void Swap<job>(job &, job &);
	// 其中Swap<job>中的<job>是可选的，因为函数的参数类型表明，这是job的一个具体化，也可以写成如下的形式
	template<> void Swap(job &, job &);		// simpler form
### 4.6 实例化和具体化
    1.通过函数调用，基于模板生成的函数定义，称为隐式实例化。
	2.可通过指令方式进行显式实例化，语法是，声明所需的种类，用<>符号指示类型，，并在声明前加上关键字template
	     template void Swop<int>(int,int); // explicit instantiation
	3.显式具体化使用template<>打头，具有单独的函数定义，与模板不同
    4.程序中使用函数来创建显式实例化
![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/9fd0a9cc-f73c-4bb1-986f-b40dc63d0e24)
![image](https://github.com/liam1992-web/cpp_study_notes/assets/61104738/8cf08b69-4f40-46e8-bf50-9c6eb23de08f)
    
	
