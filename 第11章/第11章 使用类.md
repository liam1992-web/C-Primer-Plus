## 1.不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象消失，引用将指向不存在的数据。
## 2.运算符重载示例
    total = coding.operator+(fixing);   //函数调用形式
    total = coding + fixing;            //运算符重载形式
这两种表示法都将调用operator+()方法。在运算符表示法中，运算符左侧的对象是调用对象，运算符右侧的对象是作为参数传递的对象。
## 3.友元
    C++控制对类对象私有部分的访问。通常公有类方法提供唯一的访问途径。
    C++提供了另外一种形式的访问权限：友元。
    友元有3种：友元函数、友元类、友元成员函数。
    通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。
//当运算符重载，比如*，用一个对象与一个内置类型int相乘，使用成员函数operator*(int n)，在实际表达式中，对象在左侧，整型放右侧；但是遇到整型在左侧的情况，则无法使用成员函数；因此可以进行非成员重载运算符函数Time operator*(int n, const Time & t),这样就可以解决操作数顺序的问题；但是非成员函数无法访问类的私有成员，因此需要使用友元函数，提供访问权限。
    
    创建友元：创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend;
    原型意味着，虽然函数是在类声明中声明的，但它不是成员函数，所有不能使用成员运算符来调用。
    虽然函数不是成员函数，但它与成员函数的访问权限相同。
    第二步是编写函数定义。因为它不是成员函数，所以不要使用 类限定符 class::
    另外不要再定义中使用关键字 friend
// 如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。

## 4.所有的类方法作用域都为整个类，通过导入类名，无需提供其它using声明就可以使用类方法。
## 5.类的自动转换和强制类型转换
    只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显式转换，否则也可以用于隐式转换
    
    Stonewt(double lbs);    //构造函数声明，只有一个参数
    可以这样编写代码：
    Stonewt myCat;  // create a Stonewt object
    myCat = 19.6;   // use Stonewt(double) to convert 19.6 to Stonewt
    程序将使用构造函数Stone(double)来创建一个临时的Stonewt对象，并将19.6作为初始值。
    随后采用逐成员赋值方式将临时对象的内容复制到myCat中。
    这一过程称为隐式转换，因为它是自动进行的，而不需要显式强制类型转换。

    只有接受一个参数的构造函数才能作为转换函数。
    下面的构造函数有两个参数，因此不能用来转换类型：
    Stonewt(int stn, double lbs); // not a conversion function
    然而，如果给第二个参数提供默认值，它便可用于转化int:
    Stonewt(int stn, double lbs = 0); // int-to-Stonewt conversion


    但自动类型转换函数的特性并非总是需要，可能会导致意外的类型转换，因此C++新增了关键字explicit，用于关闭这种特性。可以这样声明构造函数：
    explicit Stonewt(double lbs); // no implicit conversions allowed
    这将关闭上述实例中介绍的隐式转换，但仍允许显式转换，即显式强制类型转换：
    Stonewt myCat;              // create a Stonewt object
    myCat = 19.6;               // not valid if Stonewt(double) is declared as explicit
    myCat = Stonewt(19.6);      // ok, an explicit conversion
    myCat = (Stonewt)19.6;      // ok, old form for explicit typecast

    编译器在什么时候使用Stonewt(double)函数呢？如果在声明中使用了关键字explicit,则Stonewt(double)将只用于显式强制类型转换，否则还可以用于下面的隐式转换。
    将Stonewt对象初始化为double值时
    将double值赋给Stonewt对象
    将double值传递给接受Stonewt参数的函数时
    返回值被声明为Stonewt的函数试图返回double值时
    在上述任意一种情况下，使用可转换为double类型的内置类型时

    函数原型化提供的参数匹配过程，允许使用Stonewt(double)构造函数来转换其他数值类型。也就是说，下面那两条语句首先将int转换为double，然后使用Stonewt(double)构造函数。
    Stonewt Jumbo(7000);        // use Stonewt(double), converting int to double
    Jumbo = 7300;               // use Stonewt(double), converting int to double
    然而，当且仅当转换不存在二义性时，才会进行这种二步转换。也就是说，如果还定义了构造函数Stonewt(long)，则编译器将拒绝这些语句，可能指出int可被抓换位long或double，因此调用存在二义性。
    